## DESCRIPTION
## Calculus
## ENDDESCRIPTION

## Tagged by tda2d

## DBsubject(Calculus - single variable)
## DBchapter(Integrals)
## DBsection(Riemann sums)
## Institution(Rochester)
## MLT(small)
## MLTleader(1)
## Level(2)
## MO(1)
## KEYWORDS('integral' 'summation' 'area' 'riemann')



########################################
# this file automatically moved
#	from local/Library/Rochester/setIntegrals0Theory/sc5_2_3_mo.pg 
#	to setintegrals_approximating_area_using_rectangles/sc5_2_3_mo.pg 
#	on 2023-05-26 12:01:24.489989 by silviana amethyst.
# if this problem uses static images, they should also have been moved from that location to here.
# if not, look in the source directory for images that didn't make it.
########################################




########################################
# this file automatically moved
#	from setintegrals_approximating_area_using_rectangles/sc5_2_3_mo.pg 
#	to setintegrals_approximating_area_using_rectangles_-_training/sc5_2_3_mo.pg 
#	on 2023-07-01 15:08:39.906823 by silviana amethyst.
# if this problem uses static images, they should also have been moved from that location to here.
# if not, look in the source directory for images that didn't make it.
########################################


DOCUMENT();        # This should be the first executable line in the problem.
loadMacros(
"PGstandard.pl",
"MathObjects.pl",   							
"PGcourse.pl"         # Customization file for the course
);

TEXT(beginproblem());
########################################
# Setup

Context("Numeric");
$showPartialCorrectAnswers = 1;

Context()->flags->set(reduceConstants=>0);
Context()->flags->set(reduceConstantFunctions=>0);

$a = random(0,5,1);      ## left endpoint
$dx = random(2,4,1);        ## delta x
$n = random(3,4,1);
$b = $a + $n*$dx;            ## right endpoint, 3 subdivisions
$c = random(2,4,1);
$d = random(2,4,1);
$e = random(1,6,1);

$f = Formula("$c*x**2 + $d*x + $e");

# The following function receives a value and returns the value of the function $f at the value of the input
sub myfunc {
    $x = shift @_;
    return $f->eval(x=>"$x");
}

# This foreach loop populates an array of value of the function $f  at 0,1,...,n-1
@array = ();
foreach $i (0 .. $n - 1) {
push (@array, myfunc($a + $dx*$i));
}

$str = join("+" , @array);     # Create a string out of the arrays values
$left = Compute("$dx*($str)");  # Riemann approx with left endpoints 

# This foreach loop populates an array of value of the function $f  at 1,...,n
@array = ();
foreach $i (1 .. $n) {
push (@array, myfunc($a + $dx*$i));
}

$str = join("+" , @array);         # Create a string out of the arrays values
$right = Compute("$dx*($str)");     # Riemann approx with right endpoints

########################################
# Main Text

Context()->texStrings;
BEGIN_TEXT

Approximate the area between \(f(x)=$f\) and the \(x\)-axis on the interval \([$a, $b]\).
$PAR
(a) Use left endpoints and \( n= $n \):
$PAR
\(L_$n =\) \{ans_rule(50)\}
$PAR
(b) Use right endpoints and \( n = $n \):
$PAR
\(R_$n =\) \{ans_rule(50)\} 

$PAR
\{ theresahint \}
END_TEXT


BEGIN_HINT


Note that the width of each rectangle is \(\Delta x = ($b-$a)/$n\).  $PAR

I like to use a table to help me solve this, with the following columns:$BR

\( \begin{array}{c|c|c | c}
j & x_j & f(x_j) & f(x_j) \Delta x \\ \hline 
0 & x_0 = $a & f($a) & f($a) \cdot $dx \\
1 & x_1 = $a+\Delta x & f(x_1) & f(x_1) \cdot $dx\\
\vdots &&& \\
$n & x_$n = $b & f($b) & f($b)\cdot $dx
\end{array}
\)

$PAR
The benefit of the table is that now I can just add up values from the last column, which represent the areas of individual rectangles. 

$PAR

!!! Remember that the left endpoint method (\(L_$n\)) doesn't use the right-most endpoint.  Vice-versa for  \(R_$n\).  That is, the left endpoint method omits the bottom row of the table, and the right endpoint method omits the top row of the table. 



\{amethystHint("$PAR$HR$PAR If you're looking for a conceptual explanation of what we're doing in this problem, check out this 5-minute video by Prof. Amethyst:$PAR")\}
\{ youtubeAmethyst("BAMQr94In0E") \}


\{amethystHint("$PAR$HR$PAR If you're looking for a model of how to compute, check out this full-length lecture video, particularly starting at 55 minutes: $PAR")\}
\{ youtubeAmethyst("R7uWUvIkwI0") \}
END_HINT
Context()->normalStrings;

########################################
# Answers

ANS($left->cmp);
ANS($right->cmp);

########################################


;

;
ENDDOCUMENT();